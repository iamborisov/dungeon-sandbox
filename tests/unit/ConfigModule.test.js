// Unit Tests for ConfigModule\n// Enterprise-grade testing with comprehensive coverage\n\ndescribe('ConfigModule', () => {\n    let app, configModule;\n    \n    beforeEach(() => {\n        // Mock application\n        app = {\n            eventBus: {\n                emit: jest.fn(),\n                on: jest.fn()\n            },\n            setState: jest.fn(),\n            config: {}\n        };\n        \n        configModule = new ConfigModule(app);\n    });\n    \n    describe('initialization', () => {\n        test('should initialize with default configuration', async () => {\n            await configModule.initialize();\n            \n            expect(configModule.config).toBeDefined();\n            expect(configModule.config.renderer).toBeDefined();\n            expect(configModule.config.camera).toBeDefined();\n            expect(configModule.config.controls).toBeDefined();\n        });\n        \n        test('should detect mobile environment correctly', async () => {\n            // Mock mobile user agent\n            Object.defineProperty(navigator, 'userAgent', {\n                writable: true,\n                value: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X)'\n            });\n            \n            await configModule.initialize();\n            \n            expect(configModule.config.environment.isMobile).toBe(true);\n            expect(configModule.config.renderer.antialias).toBe(false);\n        });\n        \n        test('should detect desktop environment correctly', async () => {\n            Object.defineProperty(navigator, 'userAgent', {\n                writable: true,\n                value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            });\n            \n            await configModule.initialize();\n            \n            expect(configModule.config.environment.isMobile).toBe(false);\n            expect(configModule.config.renderer.antialias).toBe(true);\n        });\n    });\n    \n    describe('configuration management', () => {\n        beforeEach(async () => {\n            await configModule.initialize();\n        });\n        \n        test('should get configuration values by path', () => {\n            const value = configModule.get('renderer.antialias');\n            expect(typeof value).toBe('boolean');\n        });\n        \n        test('should return default value for missing paths', () => {\n            const value = configModule.get('nonexistent.path', 'default');\n            expect(value).toBe('default');\n        });\n        \n        test('should set configuration values by path', () => {\n            configModule.set('renderer.pixelRatio', 1.5);\n            \n            const value = configModule.get('renderer.pixelRatio');\n            expect(value).toBe(1.5);\n            expect(app.eventBus.emit).toHaveBeenCalledWith('config:changed', {\n                path: 'renderer.pixelRatio',\n                value: 1.5\n            });\n        });\n        \n        test('should merge partial configurations', () => {\n            const partialConfig = {\n                renderer: {\n                    customSetting: true\n                },\n                newSection: {\n                    value: 'test'\n                }\n            };\n            \n            configModule.update(partialConfig);\n            \n            expect(configModule.get('renderer.customSetting')).toBe(true);\n            expect(configModule.get('newSection.value')).toBe('test');\n            expect(configModule.get('camera.fov')).toBeDefined(); // Original value preserved\n        });\n    });\n    \n    describe('WebGL detection', () => {\n        test('should detect WebGL2 support', () => {\n            // Mock WebGL2 context\n            const mockCanvas = {\n                getContext: jest.fn().mockReturnValue({})\n            };\n            document.createElement = jest.fn().mockReturnValue(mockCanvas);\n            \n            const hasWebGL2 = configModule.checkWebGL2Support();\n            \n            expect(mockCanvas.getContext).toHaveBeenCalledWith('webgl2');\n            expect(hasWebGL2).toBe(true);\n        });\n        \n        test('should handle WebGL2 not supported', () => {\n            const mockCanvas = {\n                getContext: jest.fn().mockReturnValue(null)\n            };\n            document.createElement = jest.fn().mockReturnValue(mockCanvas);\n            \n            const hasWebGL2 = configModule.checkWebGL2Support();\n            \n            expect(hasWebGL2).toBe(false);\n        });\n        \n        test('should handle WebGL context creation errors', () => {\n            const mockCanvas = {\n                getContext: jest.fn().mockImplementation(() => {\n                    throw new Error('WebGL not supported');\n                })\n            };\n            document.createElement = jest.fn().mockReturnValue(mockCanvas);\n            \n            const hasWebGL2 = configModule.checkWebGL2Support();\n            \n            expect(hasWebGL2).toBe(false);\n        });\n    });\n    \n    describe('device detection', () => {\n        test('should detect low-end device by memory', () => {\n            Object.defineProperty(navigator, 'deviceMemory', {\n                writable: true,\n                value: 2\n            });\n            \n            const isLowEnd = configModule.detectLowEndDevice();\n            \n            expect(isLowEnd).toBe(true);\n        });\n        \n        test('should detect low-end device by CPU cores', () => {\n            Object.defineProperty(navigator, 'hardwareConcurrency', {\n                writable: true,\n                value: 2\n            });\n            Object.defineProperty(navigator, 'deviceMemory', {\n                writable: true,\n                value: 8\n            });\n            \n            const isLowEnd = configModule.detectLowEndDevice();\n            \n            expect(isLowEnd).toBe(true);\n        });\n        \n        test('should detect high-end device', () => {\n            Object.defineProperty(navigator, 'deviceMemory', {\n                writable: true,\n                value: 8\n            });\n            Object.defineProperty(navigator, 'hardwareConcurrency', {\n                writable: true,\n                value: 8\n            });\n            \n            const isLowEnd = configModule.detectLowEndDevice();\n            \n            expect(isLowEnd).toBe(false);\n        });\n    });\n    \n    describe('configuration validation', () => {\n        beforeEach(async () => {\n            await configModule.initialize();\n        });\n        \n        test('should validate valid configuration', () => {\n            const result = configModule.validate();\n            \n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n        });\n        \n        test('should detect invalid pixel ratio', () => {\n            configModule.set('renderer.pixelRatio', null);\n            \n            const result = configModule.validate();\n            \n            expect(result.isValid).toBe(false);\n            expect(result.errors).toContain('Invalid renderer pixel ratio configuration');\n        });\n        \n        test('should detect invalid camera FOV', () => {\n            configModule.set('camera.fov', -10);\n            \n            const result = configModule.validate();\n            \n            expect(result.isValid).toBe(false);\n            expect(result.errors).toContain('Invalid camera FOV configuration');\n        });\n    });\n    \n    describe('config merging', () => {\n        test('should merge nested objects correctly', () => {\n            const config1 = {\n                a: {\n                    b: {\n                        c: 1,\n                        d: 2\n                    },\n                    e: 3\n                }\n            };\n            \n            const config2 = {\n                a: {\n                    b: {\n                        c: 10,\n                        f: 4\n                    },\n                    g: 5\n                }\n            };\n            \n            const merged = configModule.mergeConfigs(config1, config2);\n            \n            expect(merged.a.b.c).toBe(10); // Override\n            expect(merged.a.b.d).toBe(2);  // Preserve\n            expect(merged.a.b.f).toBe(4);  // Add new\n            expect(merged.a.e).toBe(3);    // Preserve\n            expect(merged.a.g).toBe(5);    // Add new\n        });\n        \n        test('should handle array values correctly', () => {\n            const config1 = {\n                camera: {\n                    position: [1, 2, 3]\n                }\n            };\n            \n            const config2 = {\n                camera: {\n                    position: [4, 5, 6]\n                }\n            };\n            \n            const merged = configModule.mergeConfigs(config1, config2);\n            \n            expect(merged.camera.position).toEqual([4, 5, 6]);\n        });\n    });\n    \n    describe('environment adaptation', () => {\n        test('should adapt configuration for mobile devices', async () => {\n            Object.defineProperty(navigator, 'userAgent', {\n                writable: true,\n                value: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X)'\n            });\n            \n            Object.defineProperty(window, 'innerWidth', {\n                writable: true,\n                value: 375\n            });\n            \n            await configModule.initialize();\n            \n            expect(configModule.get('environment.isMobile')).toBe(true);\n            expect(configModule.get('renderer.antialias')).toBe(false);\n            expect(configModule.get('performance.targetFPS')).toBe(30);\n        });\n        \n        test('should maintain desktop configuration for desktop devices', async () => {\n            Object.defineProperty(navigator, 'userAgent', {\n                writable: true,\n                value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            });\n            \n            Object.defineProperty(window, 'innerWidth', {\n                writable: true,\n                value: 1920\n            });\n            \n            await configModule.initialize();\n            \n            expect(configModule.get('environment.isMobile')).toBe(false);\n            expect(configModule.get('renderer.antialias')).toBe(true);\n            expect(configModule.get('performance.targetFPS')).toBe(60);\n        });\n    });\n    \n    describe('event emission', () => {\n        beforeEach(async () => {\n            await configModule.initialize();\n        });\n        \n        test('should emit config:loaded on initialization', () => {\n            expect(app.eventBus.emit).toHaveBeenCalledWith('config:loaded', configModule.config);\n        });\n        \n        test('should emit config:changed on value change', () => {\n            configModule.set('test.value', 'changed');\n            \n            expect(app.eventBus.emit).toHaveBeenCalledWith('config:changed', {\n                path: 'test.value',\n                value: 'changed'\n            });\n        });\n        \n        test('should emit config:updated on configuration update', () => {\n            const partialConfig = { newSection: { value: 'test' } };\n            configModule.update(partialConfig);\n            \n            expect(app.eventBus.emit).toHaveBeenCalledWith('config:updated', configModule.config);\n        });\n    });\n});\n\n// Integration tests\ndescribe('ConfigModule Integration', () => {\n    test('should work with real browser environment', async () => {\n        const mockApp = {\n            eventBus: { emit: jest.fn(), on: jest.fn() },\n            setState: jest.fn()\n        };\n        \n        const configModule = new ConfigModule(mockApp);\n        \n        await expect(configModule.initialize()).resolves.not.toThrow();\n        expect(configModule.config).toBeDefined();\n        expect(mockApp.setState).toHaveBeenCalledWith('config', configModule.config);\n    });\n    \n    test('should provide consistent configuration across multiple instances', async () => {\n        const app1 = { eventBus: { emit: jest.fn(), on: jest.fn() }, setState: jest.fn() };\n        const app2 = { eventBus: { emit: jest.fn(), on: jest.fn() }, setState: jest.fn() };\n        \n        const config1 = new ConfigModule(app1);\n        const config2 = new ConfigModule(app2);\n        \n        await config1.initialize();\n        await config2.initialize();\n        \n        // Should have same default values\n        expect(config1.get('camera.fov')).toBe(config2.get('camera.fov'));\n        expect(config1.get('renderer.powerPreference')).toBe(config2.get('renderer.powerPreference'));\n    });\n});\n\n// Performance tests\ndescribe('ConfigModule Performance', () => {\n    let configModule;\n    \n    beforeEach(async () => {\n        const mockApp = {\n            eventBus: { emit: jest.fn(), on: jest.fn() },\n            setState: jest.fn()\n        };\n        \n        configModule = new ConfigModule(mockApp);\n        await configModule.initialize();\n    });\n    \n    test('should handle large configuration objects efficiently', () => {\n        const largeConfig = {};\n        \n        // Create a large nested configuration\n        for (let i = 0; i < 100; i++) {\n            largeConfig[`section${i}`] = {};\n            for (let j = 0; j < 100; j++) {\n                largeConfig[`section${i}`][`setting${j}`] = `value${j}`;\n            }\n        }\n        \n        const startTime = performance.now();\n        configModule.update(largeConfig);\n        const endTime = performance.now();\n        \n        expect(endTime - startTime).toBeLessThan(100); // Should complete within 100ms\n    });\n    \n    test('should perform path-based gets efficiently', () => {\n        const iterations = 1000;\n        const startTime = performance.now();\n        \n        for (let i = 0; i < iterations; i++) {\n            configModule.get('renderer.antialias');\n            configModule.get('camera.position');\n            configModule.get('controls.enableDamping');\n        }\n        \n        const endTime = performance.now();\n        const timePerOperation = (endTime - startTime) / (iterations * 3);\n        \n        expect(timePerOperation).toBeLessThan(0.1); // Should be very fast\n    });\n});"