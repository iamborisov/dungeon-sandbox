<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gaussian Splat Viewer</title>
    
    <!-- Telegram Web App Script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Import Map for Three.js ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    
    <!-- Load Three.js and modules as ES modules -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        
        // Make THREE available globally
        window.THREE = THREE;
        window.THREE.OrbitControls = OrbitControls;
        window.THREE.PLYLoader = PLYLoader;
        
        console.log('✅ THREE.js loaded successfully, version:', THREE.REVISION);
        console.log('✅ OrbitControls and PLYLoader loaded successfully');
        
        // Trigger the app initialization
        window.dispatchEvent(new Event('threejs-ready'));
    </script>
    <!-- App initialization -->
    <script>
        // Wait for Three.js to be ready
        window.addEventListener('threejs-ready', function() {
            console.log('THREE.js modules ready, initializing app...');
            initializeApp();
        });
        
        // Fallback in case ES modules aren't supported
        window.addEventListener('load', function() {
            // Give ES modules time to load
            setTimeout(() => {
                if (typeof THREE === 'undefined') {
                    console.warn('ES modules failed, loading legacy Three.js...');
                    loadLegacyThreeJS();
                }
            }, 1000);
        });
        
        function loadLegacyThreeJS() {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/three@0.158.0/build/three.min.js';
            script.onload = function() {
                console.log('Legacy THREE.js loaded successfully, version:', THREE.REVISION);
                
                // Load OrbitControls
                const controlsScript = document.createElement('script');
                controlsScript.src = 'https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js';
                controlsScript.onload = function() {
                    console.log('Legacy OrbitControls loaded');
                    initializeApp();
                };
                document.head.appendChild(controlsScript);
            };
            document.head.appendChild(script);
        }
    </script>
    
    <style>
        :root {
            --tg-theme-bg-color: #ffffff;
            --tg-theme-text-color: #000000;
            --tg-theme-hint-color: #999999;
            --tg-theme-link-color: #2481cc;
            --tg-theme-button-color: #2481cc;
            --tg-theme-button-text-color: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--tg-theme-bg-color);
            color: var(--tg-theme-text-color);
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }
        
        #renderCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none;
            outline: none;
        }
        
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--tg-theme-bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--tg-theme-hint-color);
            border-top: 4px solid var(--tg-theme-button-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: var(--tg-theme-text-color);
            font-size: 16px;
            margin-bottom: 8px;
        }
        
        .loading-hint {
            color: var(--tg-theme-hint-color);
            font-size: 14px;
            text-align: center;
            max-width: 280px;
        }
        
        #errorOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--tg-theme-bg-color);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            padding: 20px;
        }
        
        .error-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .error-title {
            color: var(--tg-theme-text-color);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .error-message {
            color: var(--tg-theme-hint-color);
            font-size: 14px;
            text-align: center;
            line-height: 1.4;
            max-width: 300px;
        }
        
        .retry-button {
            margin-top: 20px;
            padding: 12px 24px;
            background-color: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .retry-button:active {
            opacity: 0.8;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px;
            display: none;
            flex-direction: row;
            justify-content: space-around;
            z-index: 100;
        }
        
        .control-button {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .control-button:active {
            opacity: 0.8;
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading Gaussian Splat...</div>
        <div class="loading-hint">Preparing 3D viewer for optimal mobile experience</div>
    </div>
    
    <!-- Error Overlay -->
    <div id="errorOverlay">
        <div class="error-icon">⚠️</div>
        <div class="error-title">Unable to Load Splat</div>
        <div class="error-message" id="errorMessage">Your device may not support WebGL or the splat file couldn't be loaded.</div>
        <button class="retry-button" onclick="retryLoading()">Try Again</button>
    </div>
    
    <!-- Render Canvas -->
    <canvas id="renderCanvas"></canvas>
    
    <!-- Controls -->
    <div id="controls">
        <button class="control-button" onclick="resetCamera()">Reset View</button>
        <button class="control-button" onclick="toggleQuality()">Quality</button>
    </div>
    
    <script>
        // Telegram Web App initialization
        let tg = window.Telegram?.WebApp;
        
        if (tg) {
            tg.ready();
            tg.expand();
            
            // Only use swipe controls if supported
            if (tg.version >= 6.1 && tg.disableVerticalSwipes) {
                tg.disableVerticalSwipes();
            }
            
            // Apply Telegram theme colors
            document.documentElement.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#ffffff');
            document.documentElement.style.setProperty('--tg-theme-text-color', tg.themeParams.text_color || '#000000');
            document.documentElement.style.setProperty('--tg-theme-hint-color', tg.themeParams.hint_color || '#999999');
            document.documentElement.style.setProperty('--tg-theme-button-color', tg.themeParams.button_color || '#2481cc');
            document.documentElement.style.setProperty('--tg-theme-button-text-color', tg.themeParams.button_text_color || '#ffffff');
            
            // Handle back button only if supported
            if (tg.version >= 6.1 && tg.BackButton) {
                tg.BackButton.onClick(() => {
                    tg.close();
                });
            }
        }
        
        // Global variables
        let renderer, scene, camera, controls, canvas, splatMesh;
        let isLowQuality = false;
        
        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         window.innerWidth <= 768;
        
        // WebGL support check
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                return !!gl;
            } catch (e) {
                return false;
            }
        }
        
        function showError(message) {
            document.getElementById('loadingOverlay').classList.add('hidden');
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorOverlay').style.display = 'flex';
            
            if (tg) {
                tg.MainButton.setText('Close App');
                tg.MainButton.show();
                tg.MainButton.onClick(() => tg.close());
            }
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
            document.getElementById('controls').style.display = 'flex';
            
            if (tg) {
                tg.MainButton.setText('Loaded Successfully');
                tg.MainButton.color = '#4CAF50';
                tg.MainButton.show();
                setTimeout(() => tg.MainButton.hide(), 2000);
            }
        }
        
        function updateLoadingText(text) {
            document.querySelector('.loading-text').textContent = text;
        }
        
        async function initThreeJS() {
            try {
                // Check if THREE.js is loaded
                if (typeof THREE === 'undefined') {
                    throw new Error('THREE.js library failed to load');
                }
                
                if (!checkWebGLSupport()) {
                    throw new Error('WebGL is not supported on this device');
                }
                
                canvas = document.getElementById('renderCanvas');
                
                updateLoadingText('Initializing 3D Scene...');
                
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // Setup camera
                setupCamera();
                
                // Create renderer with mobile optimizations
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: !isMobile,
                    alpha: false,
                    premultipliedAlpha: false,
                    preserveDrawingBuffer: false,
                    powerPreference: "high-performance"
                });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                
                // Mobile optimizations
                if (isMobile) {
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2) * 0.7);
                    isLowQuality = true;
                } else {
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                }
                
                // Setup controls
                setupControls();
                
                // Setup lighting
                setupLighting();
                
                updateLoadingText('Loading Gaussian Splat Data...');
                
                // Load splat
                await loadGaussianSplat();
                
                // Start render loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    if (controls) {
                        controls.update();
                    }
                    
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                }
                animate();
                
                // Handle resize
                window.addEventListener('resize', onWindowResize);
                
                hideLoading();
                
            } catch (error) {
                console.error('Three.js initialization error:', error);
                showError(error.message || 'Failed to initialize 3D viewer');
            }
        }
        
        function setupCamera() {
            // Create perspective camera
            camera = new THREE.PerspectiveCamera(
                75, // FOV
                window.innerWidth / window.innerHeight, // aspect ratio
                0.1, // near
                1000 // far
            );
            
            // Position camera
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
        }
        
        function setupControls() {
            // Check if OrbitControls is available
            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('OrbitControls not available, using basic mouse/touch events');
                controls = null;
                return;
            }
            
            try {
                // Create orbit controls for mobile-optimized interaction
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                
                // Control settings for both mobile and desktop
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                
                // Limit camera movement
                controls.minDistance = 2;
                controls.maxDistance = 50;
                controls.maxPolarAngle = Math.PI * 0.9;
                controls.minPolarAngle = Math.PI * 0.1;
                
                // Mouse controls for desktop
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN
                };
                
                // Touch settings for mobile
                controls.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                };
                
                // Enable all interaction types
                controls.enableRotate = true;
                controls.enableZoom = true;
                controls.enablePan = true;
                
                // Auto-rotate for demo (optional)
                controls.autoRotate = false;
                controls.autoRotateSpeed = 0.5;
                
                controls.target.set(0, 0, 0);
                
            } catch (error) {
                console.warn('Failed to initialize OrbitControls:', error);
                controls = null;
            }
        }
        
        function setupLighting() {
            // Add ambient light for basic visibility
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add point light for better illumination
            const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        async function loadGaussianSplat() {
            try {
                updateLoadingText('Loading Gaussian Splat...');
                
                // Try to load the actual banana.ply file first
                if (typeof THREE.PLYLoader !== 'undefined') {
                    try {
                        const loader = new THREE.PLYLoader();
                        updateLoadingText('Loading banana.ply...');
                        
                        const geometry = await new Promise((resolve, reject) => {
                            loader.load('/assets/splats/banana.ply', resolve, undefined, reject);
                        });
                        
                        // Create material for the PLY file
                        const material = new THREE.PointsMaterial({
                            size: 0.02,
                            vertexColors: geometry.attributes.color ? true : false,
                            color: geometry.attributes.color ? 0xffffff : 0xffdd00
                        });
                        
                        splatMesh = new THREE.Points(geometry, material);
                        scene.add(splatMesh);
                        
                        console.log('✅ Successfully loaded banana.ply');
                        
                    } catch (plyError) {
                        console.warn('Failed to load banana.ply, using placeholder:', plyError);
                        createPlaceholderSplat();
                    }
                } else {
                    console.warn('PLYLoader not available, using placeholder');
                    createPlaceholderSplat();
                }
                
                function createPlaceholderSplat() {
                    updateLoadingText('Creating Splat Visualization...');
                    
                    // Create main sphere as placeholder
                    const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
                    const sphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0xcc9966,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    scene.add(sphere);
                    splatMesh = sphere;
                
                    // Create particle-like points to simulate splat appearance
                    const pointsGeometry = new THREE.BufferGeometry();
                    const pointsCount = 1000;
                    const positions = new Float32Array(pointsCount * 3);
                    const colors = new Float32Array(pointsCount * 3);
                    
                    for (let i = 0; i < pointsCount; i++) {
                        const i3 = i * 3;
                        
                        // Random positions around the sphere
                        const radius = 2 + Math.random() * 3;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        
                        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                        positions[i3 + 2] = radius * Math.cos(phi);
                        
                        // Random colors
                        colors[i3] = Math.random();
                        colors[i3 + 1] = Math.random();
                        colors[i3 + 2] = Math.random();
                    }
                    
                    pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    pointsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    
                    const pointsMaterial = new THREE.PointsMaterial({
                        size: 0.05,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const points = new THREE.Points(pointsGeometry, pointsMaterial);
                    scene.add(points);
                }
                
                /*
                 * ACTUAL GAUSSIAN SPLAT LOADING CODE WOULD GO HERE:
                 * 
                 * // Using the Gaussian Splats 3D library:
                 * const viewer = new GaussianSplats3D.Viewer({
                 *     'cameraUp': [0, -1, -0.6],
                 *     'initialCameraPosition': [-1, -4, 6],
                 *     'initialCameraLookAt': [0, 4, 0]
                 * });
                 * viewer.addSplatScene('assets/splat.ply')
                 *   .then(() => {
                 *       viewer.start();
                 *   });
                 * 
                 * // Or load .ply files directly:
                 * const loader = new THREE.PLYLoader();
                 * loader.load('assets/splat.ply', (geometry) => {
                 *     const material = new THREE.PointsMaterial({ size: 0.1 });
                 *     splatMesh = new THREE.Points(geometry, material);
                 *     scene.add(splatMesh);
                 * });
                 */
                
                // Center camera on the splat
                if (controls && splatMesh) {
                    controls.target.copy(splatMesh.position);
                }
                
                updateLoadingText('Optimizing for Mobile...');
                
                // Apply mobile optimizations
                if (isMobile) {
                    applyMobileOptimizations();
                }
                
            } catch (error) {
                throw new Error(`Failed to load Gaussian splat: ${error.message}`);
            }
        }
        
        function applyMobileOptimizations() {
            // Reduce point count for mobile devices
            const points = scene.children.find(child => child.type === 'Points');
            if (points && isMobile) {
                const geometry = points.geometry;
                const positions = geometry.attributes.position.array;
                const colors = geometry.attributes.color.array;
                
                // Reduce to half the points for mobile
                const reducedCount = Math.floor(positions.length / 6); // /6 because /2 for half points and /3 for xyz
                const newPositions = new Float32Array(reducedCount * 3);
                const newColors = new Float32Array(reducedCount * 3);
                
                for (let i = 0; i < reducedCount; i++) {
                    const srcIndex = i * 6; // Skip every other point
                    const dstIndex = i * 3;
                    
                    newPositions[dstIndex] = positions[srcIndex];
                    newPositions[dstIndex + 1] = positions[srcIndex + 1];
                    newPositions[dstIndex + 2] = positions[srcIndex + 2];
                    
                    newColors[dstIndex] = colors[srcIndex];
                    newColors[dstIndex + 1] = colors[srcIndex + 1];
                    newColors[dstIndex + 2] = colors[srcIndex + 2];
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(newColors, 3));
            }
            
            // Reduce shadow quality for mobile
            if (renderer && isMobile) {
                renderer.shadowMap.enabled = false;
                renderer.antialias = false;
            }
        }
        
        // Control functions
        function resetCamera() {
            if (camera && controls && splatMesh) {
                camera.position.set(10, 10, 10);
                controls.target.copy(splatMesh.position);
                controls.update();
            }
        }
        
        function toggleQuality() {
            if (!renderer) return;
            
            isLowQuality = !isLowQuality;
            
            if (isLowQuality) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2) * 0.6);
                document.querySelector('#controls .control-button:nth-child(2)').textContent = 'High Quality';
            } else {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.querySelector('#controls .control-button:nth-child(2)').textContent = 'Low Quality';
            }
            
            if (tg) {
                tg.HapticFeedback.selectionChanged();
            }
        }
        
        function retryLoading() {
            document.getElementById('errorOverlay').style.display = 'none';
            document.getElementById('loadingOverlay').classList.remove('hidden');
            
            // Clean up previous attempt
            if (renderer) {
                renderer.dispose();
                renderer = null;
            }
            if (scene) {
                scene.clear();
                scene = null;
            }
            
            // Retry initialization
            setTimeout(initThreeJS, 500);
        }
        
        // Show main button in Telegram
        if (tg) {
            tg.MainButton.setText('Loading...');
            tg.MainButton.show();
        }
        
        // Main app initialization function
        function initializeApp() {
            if (typeof THREE !== 'undefined' && (THREE.OrbitControls || window.THREE.OrbitControls)) {
                console.log('THREE.js and all modules ready, initializing...');
                initThreeJS();
            } else {
                console.log('THREE.js modules not ready, retrying...');
                setTimeout(initializeApp, 200);
            }
        }
        
        // Handle page visibility changes for performance
        document.addEventListener('visibilitychange', () => {
            if (controls) {
                if (document.hidden) {
                    controls.enabled = false;
                } else {
                    controls.enabled = true;
                }
            }
        });
    </script>
</body>
</html>